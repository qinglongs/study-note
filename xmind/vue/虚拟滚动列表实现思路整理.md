## 背景
    - 监管数据大屏（这个项目已搁置）table组件需要实现自动轮播的功能。
    - 之前使用的开源自动轮播组件，数据上1000就会有明显的掉帧现象，性能开销太大。   

## 具备能力及优缺点
    - 能力
        1.虚拟滚动
        2.无缝滚动
        3.自动轮播
        4.大数据渲染
    - 优点
        1. 对于空间的占用基本固定。
        2. 极小的计算性能开销。
    - 缺点
        1. 元素高度不一致时，不具备上述功能。

## 关键变量、节点、阶段简介

```typescript

    // dom节点：
    containerRef    // 视窗节点,该节点为虚拟滚动列表的根节点，可以控制其scrollTop属性上下滚动;
    placeholderRef  // 占位容器节点，比如列表数据为100条，每个元素高度为30px，placeholderRef.height = 100*30 + 'px';
    renderListRef   // 渲染在视窗可视区域的节点,控制其top属性，将其保持在顶部位置并且模拟数据滚动效果。

    // 变量
    totalList       // 已加载的数据数组，会随着分页请求不断递增
    renderList      // 渲染在 renderListRef 中的数组

    hasMore         // 判断分页数据是否加载完毕

    itemHeight      // 每个元素的高度
    _showNumber     // 在视窗可视区域可以展示的数据条数 _showNumber = containerRef.clinetHeight / itemHeight >> 0;
    _offest         // 视窗容器的偏移度  containerRef.scrollTop === offect

    // 阶段1（分页加载阶段，主要处理分页加载逻辑）
    1. 分页数据加载中。
    2. 分页数据加载完毕。

    // 阶段2（分页数据加载完毕后，主要处理无缝滚动逻辑）
    1. 第一次触底
    2. 第二次触底

```

## 各个模块的实现

> 虚拟列表结构

    - 分为三个部分
        1. 视窗。
        2. 占位节点。
        3. 渲染在视窗可视区域的节点。

> 虚拟列表结构示意图

![虚拟列表示意图](./WeChat60822fb9a6dbf59b3b592656dce040e2.png)

> 分页加载

    - 初始化请求page*size条数据。
    - 后续每一次触底时控制page实现分页。
    - 将请求到的数据push到totalList.
    - 数据加载完毕后，分页加载逻辑不再触发。

> 自动轮播+无缝滚动

    - 自动轮播
        - 通过控制视窗的scrollTop属性实现。
        - 在加载数据期间，自动轮播；数据加载完毕，触底后进入无缝轮播逻辑。

    - 无缝滚动（在第一触底时和第二次触底时实现）

        1. 第一次触底
            - 分页请求的数据已经加载完毕，

        2. 第二次触底
            - 追加数据后滚动触底时触发


  